var documenterSearchIndex = {"docs":
[{"location":"elements/#Markdown-AST-elements","page":"Markdown AST elements","title":"Markdown AST elements","text":"Every node in the Markdown abstract syntax tree (AST) is associated with an element[1], providing semantic information to the node (e.g. that the node is a paragraph, or a inline code snippet). In MarkdownAST, each element is an instance of some subtype of AbstractElement, and may (but does not have to) have fields that contain additional information about how to interpret the element (e.g. the language tag of a code block).\n\nIf an element does contain some fields, it is usually a mutable type so that it would be possible to update it.\n\nWhen the Markdown AST is represented using Nodes, the corresponding elements can be accessed via the .element field.\n\n[1]: This terminology mirrors how each node of the HTML DOM tree is some HTML element.","category":"section"},{"location":"elements/#Block-and-inline-nodes","page":"Markdown AST elements","title":"Block and inline nodes","text":"In the Markdown AST, the elements can, broadly, be divided into two categories: block and inline elements. The block elements represent the main, top-level structural elements of a document (e.g. paragraphs, headings, block quotes), whereas inline elements represent components of a paragraph (e.g. bold or plain text, inline math or code snippets). In MarkdownAST, every block and inline element is a subtype of AbstractBlock and AbstractInline, respectively.","category":"section"},{"location":"elements/#Constraints-on-children","page":"Markdown AST elements","title":"Constraints on children","text":"As the AST is a tree, nodes (or elements) can have other nodes or elements as children. However, it does not generally make sense for a node to have arbitrary nodes as children. For this purpose, there are methods to ensure\n\nFirst, for some elements it does not make sense for them to have any children at all (i.e. they will always be leaf nodes). Whether or not an node is a container node (i.e. whether or not it can have other elements as children) is determined by the iscontainer function.\n\nHowever, a more fine-grained control over the allowed child nodes is often necessary. For example, while a paragraph can have child nodes, it does not make sense for a paragraph to have another paragraph as a child node, and in fact it should only have inline nodes as children. Such relationships are defined by the can_contain function (e.g. for a Paragraph it only returns true if the child element is an AbstractInline).\n\nUsually, the constraint is whether a container node can contain only block elements or only inline elements.\n\nnote: Note\nSometimes it might be desireable to have even more sophisticated constraints on the elements (e.g. perhaps two elements are not allowed to directly follow each other as children of another node). However, it is not practical to over-complicate the APIs here, and simply restricting the child elements of another element seems to strike a good balance.Instead, in cases where it becomes possible to construct trees that have questionable semantics due to a weird structure that can not be restricted with can_contain, the elements should carefully document how to interpret such problematic trees (e.g. how to interpret a table that has no rows and columns).","category":"section"},{"location":"elements/#CommonMark-elements","page":"Markdown AST elements","title":"CommonMark elements","text":"The CommonMark specification specifies a set of block and inline nodes that can be used to represent Markdown documents.","category":"section"},{"location":"elements/#Julia-extension-elements","page":"Markdown AST elements","title":"Julia extension elements","text":"The Julia version of Markdown contains additional elements that do not exists in the CommonMark specification (such as tables or math). However, as MarkdownAST is meant to be interoperable with the Markdown standard library parser, it also supports additional elements to accurately represent the Julia Flavored Markdown documents.","category":"section"},{"location":"elements/#Tables","page":"Markdown AST elements","title":"Tables","text":"Tables are build up from the following elements: Table, TableBody, TableCell, TableHeader, TableRow.\n\nIn addition, to help with the complexity of the table structure, the following helper functions can be used when working with Table elements.","category":"section"},{"location":"elements/#Other-elements","page":"Markdown AST elements","title":"Other elements","text":"Document is the root element of a Markdown document.","category":"section"},{"location":"elements/#Index","page":"Markdown AST elements","title":"Index","text":"Pages = [\"elements.md\"]","category":"section"},{"location":"elements/#MarkdownAST.AbstractElement","page":"Markdown AST elements","title":"MarkdownAST.AbstractElement","text":"abstract type AbstractElement\n\nA supertype of all Markdown AST element types.\n\nUser-defined elements must not directly inherit this type, but either AbstractBlock or AbstractInline instead.\n\nInterface\n\nBy default, each element is assumed to be a leaf element that can not contain other elements as children. An iscontainer method can be defined to override this.\ncan_contain can be overridden to constrain what elements can be the direct children of another node. By default, inline container elements can contain any inline element and block container elements can contain any block element.\nElements that are implemented as mutable structs should probably implement the equality operator (==), to make sure that two different instances that are semantically the same would be considered equal.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.AbstractBlock","page":"Markdown AST elements","title":"MarkdownAST.AbstractBlock","text":"abstract type AbstractBlock <: AbstractElement\n\nSupertype of all Markdown AST block types.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.AbstractInline","page":"Markdown AST elements","title":"MarkdownAST.AbstractInline","text":"abstract type AbstractInline <: AbstractElement\n\nSupertype of all Markdown AST inline types.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.isblock","page":"Markdown AST elements","title":"MarkdownAST.isblock","text":"isblock(element::AbstractElement) -> Bool\n\nDetermines if element is a block element (a subtype of AbstractBlock).\n\n\n\n\n\n","category":"function"},{"location":"elements/#MarkdownAST.isinline","page":"Markdown AST elements","title":"MarkdownAST.isinline","text":"isinline(element::AbstractElement) -> Bool\n\nDetermines if element is an inline element (a subtype of AbstractInline).\n\n\n\n\n\n","category":"function"},{"location":"elements/#MarkdownAST.iscontainer","page":"Markdown AST elements","title":"MarkdownAST.iscontainer","text":"iscontainer(::T) where {T <: AbstractElement} -> Bool\n\nDetermines if the particular Markdown element is a container, meaning that is can contain child nodes. Adding child nodes to non-container (leaf) nodes is prohibited.\n\nBy default, each user-defined element is assumed to be a leaf node, and each container node should override this method.\n\n\n\n\n\n","category":"function"},{"location":"elements/#MarkdownAST.can_contain","page":"Markdown AST elements","title":"MarkdownAST.can_contain","text":"can_contain(parent::AbstractElement, child::AbstractElement) -> Bool\n\nDetermines if the child element can be a direct child of the parent element.\n\nThis is used to constrain the types of valid children for some elements, such as for the elements that are only allowed to have inline child elements or to make sure that Lists only contain Items.\n\nIf the parent element is a leaf node (iscontainer(parent) === false)\n\nExtended help\n\nWhen extending can_contain for custom abstract classes Markdown elements, similar to the AbstractBlock or AbstractInline elements classes, the second argument to can_contain should always be constrained exactly to ::AbstractElement, in order to avoid method ambiguities. I.e. for some abstract type AbstractT  <: AbstractElement, the method should be defined as\n\ncan_contain(parent::AbstractT, child::AbstractElement) = ...\n\nFor concrete parent types T, where the first argument is constrained as parent::T it should then be fine to take advantage of multiple dispatch when implementing can_contain.\n\n\n\n\n\n","category":"function"},{"location":"elements/#MarkdownAST.Backslash","page":"Markdown AST elements","title":"MarkdownAST.Backslash","text":"struct Backslash <: AbstractInline\n\nRepresents a backslash character \\.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.BlockQuote","page":"Markdown AST elements","title":"MarkdownAST.BlockQuote","text":"struct BlockQuote <: AbstractBlock\n\nA singleton container element representing a block quote. It must contain other block elements as children.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.Code","page":"Markdown AST elements","title":"MarkdownAST.Code","text":"mutable struct Code <: AbstractInline\n\nInline element representing an inline code span.\n\nFields\n\n.code :: String: raw code\n\nConstructors\n\nCode(code::AbstractString)\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.CodeBlock","page":"Markdown AST elements","title":"MarkdownAST.CodeBlock","text":"mutable struct CodeBlock <: AbstractBlock\n\nA leaf block representing a code block.\n\nFields\n\n.info :: String: code block info string (e.g. the programming language label)\n.code :: String: code content of the block\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.Emph","page":"Markdown AST elements","title":"MarkdownAST.Emph","text":"struct Emph <: AbstractInline\n\nInline singleton element for emphasis (e.g. italic) styling.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.HTMLBlock","page":"Markdown AST elements","title":"MarkdownAST.HTMLBlock","text":"mutable struct HTMLBlock <: AbstractBlock\n\nA leaf block representing raw HTML.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.HTMLInline","page":"Markdown AST elements","title":"MarkdownAST.HTMLInline","text":"mutable struct HTMLInline <: AbstractInline\n\nInline leaf element representing raw inline HTML.\n\nFields\n\n.html :: String: inline raw HTML\n\nConstructors\n\nHTMLInline(html::AbstractString)\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.Heading","page":"Markdown AST elements","title":"MarkdownAST.Heading","text":"mutable struct Heading <: AbstractBlock\n\nRepresents a heading of a specific level. Can only contain inline elements as children.\n\nFields\n\n.level :: Int: the level of the heading, must be between 1 and 6.\n\nConstructors\n\nHeading(level :: Integer)\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.Image","page":"Markdown AST elements","title":"MarkdownAST.Image","text":"mutable struct Image <: AbstractInline\n\nInline element representing a link to an image. Can contain other inline nodes that will represent the image description.\n\nFields\n\n.destination :: String: destination URL\n.title :: String: title attribute of the link\n\nConstructors\n\nImage(destination::AbstractString, title::AbstractString)\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.Item","page":"Markdown AST elements","title":"MarkdownAST.Item","text":"struct Item <: AbstractBlock\n\nSingleton container representing the items of a List.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.LineBreak","page":"Markdown AST elements","title":"MarkdownAST.LineBreak","text":"struct LineBreak <: AbstractInline\n\nRepresents a hard line break in a sequence of inline nodes that should lead to a newline when rendered.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.Link","page":"Markdown AST elements","title":"MarkdownAST.Link","text":"mutable struct Link <: AbstractInline\n\nInline element representing a link. Can contain other inline nodes, but should not contain other Links.\n\nFields\n\n.destination :: String: destination URL\n.title :: String: title attribute of the link\n\nConstructors\n\nLink(destination::AbstractString, title::AbstractString)\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.List","page":"Markdown AST elements","title":"MarkdownAST.List","text":"mutable struct List <: AbstractBlock\n\nRepresents a Markdown list. The children of a List should only be Items, representing individual list items.\n\nFields\n\n.type :: Symbol: determines if this is an ordered (:ordered) or an unordered (:bullet) list.\n.tight :: Bool: determines if the list should be rendered tight or loose.\n\nConstructors\n\njulia List(type :: Symbol, tight :: Bool)`\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.Paragraph","page":"Markdown AST elements","title":"MarkdownAST.Paragraph","text":"struct Paragraph <: AbstractBlock\n\nSingleton container representing a paragraph, containing only inline nodes.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.SoftBreak","page":"Markdown AST elements","title":"MarkdownAST.SoftBreak","text":"struct SoftBreak <: AbstractInline\n\nRepresents a soft break which can be rendered as a space instead.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.Strong","page":"Markdown AST elements","title":"MarkdownAST.Strong","text":"struct Strong <: AbstractInline\n\nInline singleton element for strong (e.g. bold) styling.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.Strikethrough","page":"Markdown AST elements","title":"MarkdownAST.Strikethrough","text":"struct Strikethrough <: AbstractInline\n\nInline singleton element for strikethrough styling.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.Text","page":"Markdown AST elements","title":"MarkdownAST.Text","text":"mutable struct Text <: AbstractInline\n\nInline leaf element representing a simply a span of text.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.ThematicBreak","page":"Markdown AST elements","title":"MarkdownAST.ThematicBreak","text":"struct ThematicBreak <: AbstractBlock\n\nA singleton leaf element representing a thematic break (often rendered as a horizontal rule).\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.Admonition","page":"Markdown AST elements","title":"MarkdownAST.Admonition","text":"mutable struct Admonition <: AbstractBlock\n\nA container block representing an admonition. Can contain other block elements as children.\n\nFields\n\n.category :: String: admonition category\n.title :: String: admonition title\n\nConstructors\n\nAdmonition(category :: AbstractString, title :: AbstractString)\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.DisplayMath","page":"Markdown AST elements","title":"MarkdownAST.DisplayMath","text":"mutable struct DisplayMath <: AbstractBlock\n\nLeaf block representing a mathematical display equation.\n\nFields\n\n.math :: String: TeX code of the display equation\n\nConstructors\n\nDisplayMath(math :: AbstractString)\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.FootnoteDefinition","page":"Markdown AST elements","title":"MarkdownAST.FootnoteDefinition","text":"mutable struct FootnoteDefinition <: AbstractBlock\n\nContainer block representing the definition of a footnote, containing the definitions of the footnote as children.\n\nFields\n\n.id :: String: label of the footnote\n\nConstructors\n\nFootnoteDefinition(id :: AbstractString)\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.FootnoteLink","page":"Markdown AST elements","title":"MarkdownAST.FootnoteLink","text":"mutable struct FootnoteLink <: AbstractInline\n\nInline leaf element representing a link to a footnote.\n\nFields\n\n.id :: String: label of the footnote\n\nConstructors\n\nFootnoteLink(id :: AbstractString)\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.InlineMath","page":"Markdown AST elements","title":"MarkdownAST.InlineMath","text":"mutable struct InlineMath <: AbstractInline\n\nLeaf inline element representing an inline mathematical expression.\n\nFields\n\n.math :: String: TeX code for the inline equation\n\nConstructors\n\nInlineMath(math::String)\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.JuliaValue","page":"Markdown AST elements","title":"MarkdownAST.JuliaValue","text":"struct JuliaValue <: AbstractInline\n\nInline leaf element for interpolation of Julia expressions and their evaluated values. Two JuliaValue objects are considered equal if the Julia objects they refer to are equal (even if they originate from different expressions).\n\nFields\n\n.ex :: Any: contains the original Julia expression (e.g. Expr, Symbol, or some literal value)\n.ref :: Any: stores the Julia object the expression evaluates to\n\nConstructors\n\nJuliaValue(ex, ref = nothing)\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.Table","page":"Markdown AST elements","title":"MarkdownAST.Table","text":"mutable struct Table <: TableComponent\n\nContainer block representing a table, an extension of the CommonMark spec, and should be interpreted as a rectangular grid of cells with a fixed number of rows and columns.\n\nA Table node can only contain either TableHeader or TableBody nodes as children.\nTableHeader and TableBody can only contain TableRows as children. A TableHeader should contain only a single TableRow, and any additional ones should be ignored.\nEach TableRow contains only TableCells as children. The row with the largest number of cells determines the width (number of columns) of the table.\n\nSince we can not constrain e.g. the number of children or in what order child nodes can appear in a Markdown tree, it is possible to construct tables that can be difficult to interpret. The following rules should be followed when interpreting tables:\n\nThe decendants of a Table node should be exactly be a single TableHeader followed by a TableBody.\nIf the first child is a TableBody, the header row is assumed to be a list of empty cells.\nThe rows from any nodes following the first TableBody are interpreted as additional table body rows, even if they are contained in a TableHeader.\nA Table with no children is interpreted as a table with a single empty header cell.\nA TableHeader that is the first child of a Table should only contain one TableRow.\nIf a TableHeader that is the first child of a Table contains additional rows, the additional rows are interpreted to be body rows.\nIf a TableHeader that is the first child of a Table is empty, it is assumed to represent a header row with empty cells.\nEach TableRow of a table should contain the same number of TableCell.\nAny row that has fewer cells than the longest row should be interpreted as if it is padded with additional empty cells.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.TableBody","page":"Markdown AST elements","title":"MarkdownAST.TableBody","text":"struct TableBody <: TableComponent\n\nRepresents the body of a Markdown table and should only occur as the second child of a Table node. See Table for information on how to handle other circumstances.\n\nIt can only contain TableRow elements.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.TableCell","page":"Markdown AST elements","title":"MarkdownAST.TableCell","text":"mutable struct TableCell <: TableComponent\n\nRepresents a single cell in a Markdown table. Can contain inline nodes.\n\nalign :: Symbol: declares the alignment of a cell (can be :left, :right, or :center), and should match the .spec field of the ancestor Table\nheader :: Bool: true if the cell is part of a header row, and should only be true if the cell belongs to a row that is the first\ncolumn :: Int: the column index of the cell, which should match its position in the Markdown tree\n\nIt is possible that the fields of TableCell are inconsistent with the real structure of the Markdown tree, in which case the structure or the .spec field should take precedence when interpreting the elements.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.TableHeader","page":"Markdown AST elements","title":"MarkdownAST.TableHeader","text":"struct TableHeader <: TableComponent\n\nRepresents the header portion of a Markdown table and should only occur as the first child of a Table node and should only contain a single TableRow as a child. See Table for information on how to handle other circumstances.\n\nIt can only contain TableRow elements.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.TableRow","page":"Markdown AST elements","title":"MarkdownAST.TableRow","text":"struct TableRow <: TableComponent\n\nRepresents a row of a Markdown table. Can only contain TableCells as children.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.tablerows","page":"Markdown AST elements","title":"MarkdownAST.tablerows","text":"tablerows(node::Node)\n\nReturns an iterable object containing the all the TableRow elements of a table, bypassing the intermediate TableHeader and TableBody nodes. Requires node to be a Table element.\n\nThe first element of the iterator should be interpreted to be the header of the table.\n\n\n\n\n\n","category":"function"},{"location":"elements/#MarkdownAST.tablesize","page":"Markdown AST elements","title":"MarkdownAST.tablesize","text":"tablesize(node::Node, [dim])\n\nSimilar to size, returns the number of rows and/or columns of a Table element. The optional dim argument can be passed to return just either the number of rows or columns, and must be 1 to obtain the number of rows, and 2 to obtain the number of columns.\n\nnote: Complexity\nDetermining the number of columns is an O(n times m) operation in the number of rows and columns, due to the required traversal of the linked nodes. Determining only the number of rows with tablesize(node, 1) is an O(n) operation.\n\n\n\n\n\n","category":"function"},{"location":"elements/#MarkdownAST.Document","page":"Markdown AST elements","title":"MarkdownAST.Document","text":"struct Document <: AbstractBlock\n\nSingleton top-level element of a Markdown document.\n\n\n\n\n\n","category":"type"},{"location":"astmacro/#Constructing-trees","page":"Constructing trees","title":"Constructing trees","text":"The @ast macro can be used to construct complex trees with relatively little effort, without having to construct and push all the Node instances yourself.","category":"section"},{"location":"astmacro/#MarkdownAST.@ast","page":"Constructing trees","title":"MarkdownAST.@ast","text":"@ast markdown-node-expression\n\nA macro that implements a simple domain specific language to easily and explicitly construct a Markdown AST.\n\nThe markdown-node-expression must be either:\n\nA Markdown element (i.e. some AbstractElement object), such as a constructor call (e.g. Paragraph()), function call returning an element, or a variable pointing to an element.\nA variable or an expression returning or pointing to a Node object, which will then get unlinked from its current tree and pushed as a child (together with all of its descendents).\nA do-block, with the function call part being an element (as above), and the contents of the do-block a sequence of other node expressions, i.e.\nelement do\n    child-node-expression-1\n    child-node-expression-2\n    ...\nend\n\nIn practice, a simple example might look something like\n\n@ast Document() do\n    Heading(1) do\n        \"Top-level heading\"\n    end\n    Paragraph() do\n        \"Some paragraph text\"\n    end\nend\n\nStrings are interpreted as Text(s) elements.\n\n\n\n\n\n","category":"macro"},{"location":"iteration/#Iteration-over-trees","page":"Iteration over trees","title":"Iteration over trees","text":"The Node type implements the AbstractTrees interface which provides various general tree-iteration algorithms.\n\nUsing the following MarkdownAST tree as an example:\n\nmd = @ast Document() do\n    Heading(1) do; \"Iteration example\"; end\n    Paragraph() do\n        \"MarkdownAST trees can be iterated over with \"\n        Strong() do; \"AbstractTrees\"; end\n        \".\"\n    end\n    Paragraph() do; \"To use it, load the package with\"; end\n    CodeBlock(\"julia\", \"using AbstractTrees\")\nend\nnothing # hide\n\nThe different AbstractTrees iterators, such as PostOrderDFS, PreOrderDFS, or Leaves, can be used to construct iterators from the md variable (which is an instance of Node). Each algorithm provides a way to iterate through the trees in a different way, as can be seen in the following examples:\n\nusing AbstractTrees\nfor node in PostOrderDFS(md)\n    println(node.element)\nend\n\nfor node in PreOrderDFS(md)\n    println(node.element)\nend\n\nusing AbstractTrees\nfor node in Leaves(md)\n    println(node.element)\nend","category":"section"},{"location":"stdlib/#Conversion-to-and-from-Markdown-standard-library","page":"Conversion to/from Markdown","title":"Conversion to and from Markdown standard library","text":"The Markdown standard library in Julia provides an alternative representation of the Markdown AST. In particular, the parser and AST there is internally used by Julia for docstrings, and is also used by some of the tooling in the Julia ecosystem that deals with Markdown.\n\nMarkdownAST supports bi-directional conversion between the two AST representations via the convert function. The conversion, however, is not perfect since there are differences in what and how the two libraries represent the Markdown AST.","category":"section"},{"location":"stdlib/#Conversion-from-standard-library-representation","page":"Conversion to/from Markdown","title":"Conversion from standard library representation","text":"Any AST that is produced by the Markdown standard library parser should parse into MarkdownAST AST. However, as the data structures for the elements in Markdown are pretty loose in what they allow, user-crafted Markdown ASTs may error if it does not exactly follow the conventions of the Markdown parser.\n\nDue to the differences between the Markdown representations, the following things should be kept in mind when converting from the standard library AST into MarkdownAST representation:\n\nThe standard library parser does not have a dedicated type for representing backslashes, and instead stores them as separate single-character text nodes containing a backslash (i.e. \"\\\\\").\nSoft line breaks are ignored in the standard library parser and represented with a space instead.\nStrings (or Markdown elements) interpolated into the standard library Markdown (e.g. in docstrings or with the @md_str macro) are indistinguishable from text (or corresponding Markdown) nodes in the standard library AST, and therefore will not be converted into JuliaValues.\nThe standard library allows for block-level interpolation. These get converted into inline JuliaValues wrapped in a Paragraph element.\nIn case the standard library AST contains any inline nodes in block context (e.g. as children for Markdown.MD), the get wrapped in a Paragraph element too.\nWhen converting a Markdown.Table, the resulting table will be normalized, such as adding empty cells to rows, to make sure that all rows have the same number of cells.\nFor links and images, the .title attribute is set to an empty string, since the standard library AST does not support parsing titles.\nOn Julia 1.14 and newer, Markdown.HTMLBlock values are converted to HTMLBlock elements. On older Julia versions, such nodes do not exist in the standard library AST.\nOn Julia 1.14 and newer, Markdown.HTMLInline values are converted to HTMLInline elements. On older Julia versions, such nodes do not exist in the standard library AST.","category":"section"},{"location":"stdlib/#Conversion-to-standard-library-representation","page":"Conversion to/from Markdown","title":"Conversion to standard library representation","text":"Any AST that contains only the native MarkdownAST elements can be converted into the standard library representation. The conversion of user-defined elements, however, is not supported and will lead to an error.\n\nDue to the differences between the Markdown representations, the following things should be kept in mind when converting from the MarkdownAST representation into the standard library AST:\n\nThe value from a JuliaValue element (i.e. .ref) gets stored directly in the AST (just like variable interpolation with docstrings and the @md_str macro). This means that, for example, an interpolated string or Markdown element would become a valid AST element, losing the information that it used to be interpolated.\nThe expression information in a JuliaValue element (i.e. the .ex field) gets discarded.\nThe .title attribute of Link and Image elements gets discarded.\nThe standard library does not support storing the child nodes of Image elements (i.e. \"alt text\", ![alt text]()) as AST, and it is instead reduced to a string with the help of the Markdown.plain function.\nThe standard library AST does not have dedicated elements for SoftBreak and Backslash, and these get converted into strings (i.e. text elements) instead.\nOn Julia 1.14 and newer, HTMLBlock elements are converted into Markdown.HTMLBlock. On older Julia versions they are converted into Markdown.Code(\"html\", ...).\nOn Julia 1.14 and newer, HTMLInline elements are converted into Markdown.HTMLInline. On older Julia versions they are converted into Markdown.Code(\"\", ...).","category":"section"},{"location":"stdlib/#Index","page":"Conversion to/from Markdown","title":"Index","text":"Pages = [\"stdlib.md\"]","category":"section"},{"location":"stdlib/#Base.convert-Tuple{Type{MarkdownAST.Node}, Markdown.MD}","page":"Conversion to/from Markdown","title":"Base.convert","text":"convert(::Type{Node}, md::Markdown.MD) -> Node\nconvert(::Type{Node{M}}, md::Markdown.MD, meta=M) where M -> Node{M}\n\nConverts a standard library Markdown AST into MarkdownAST representation.\n\nNote that it is not possible to convert subtrees, as only MD objects can be converted. The result will be a tree with Document as the root element.\n\nWhen the type argument passed is Node, the resulting tree will be constructed of objects of the default node type Node{Nothing}. However, it is also possible to convert into MarkdownAST trees that have custom metadata field of type M, in which case the M type must have a zero-argument constructor available, which will be called whenever a new Node object gets constructed.\n\nIt is also possible to use a custom function to construct the .meta objects via the `meta argument, which must be a callable object with a zero-argument method, and that then gets called every time a new node is constructed.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/#Base.convert-Tuple{Type{Markdown.MD}, MarkdownAST.Node}","page":"Conversion to/from Markdown","title":"Base.convert","text":"convert(::Type{Markdown.MD}, node::Node) -> Markdown.MD\n\nConverts a MarkdownAST representation of a Markdown document into the Markdown standard library representation.\n\nNote that the root node node must a Document element.\n\n\n\n\n\n","category":"method"},{"location":"tabs/#Tab-Transformation-Guide","page":"Tab Transformation Guide","title":"Tab Transformation Guide","text":"","category":"section"},{"location":"tabs/#Overview","page":"Tab Transformation Guide","title":"Overview","text":"The tab transformation system in MarkdownAST provides a way to convert tab-based admonitions (syntax: !!! tabs \"Title\") into HTMLBlocks while preserving the underlying markdown AST nodes for syntax highlighting and other downstream processing.","category":"section"},{"location":"tabs/#Problem-Statement","page":"Tab Transformation Guide","title":"Problem Statement","text":"When using tabs in documentation:\n\nOriginal issue: Simply converting Admonitions to HTML strings loses the AST information needed for syntax highlighting\nSolution: Store both the HTML structure and preserve the original AST nodes through node metadata","category":"section"},{"location":"tabs/#Architecture","page":"Tab Transformation Guide","title":"Architecture","text":"","category":"section"},{"location":"tabs/#Node-Metadata-Strategy","page":"Tab Transformation Guide","title":"Node Metadata Strategy","text":"The transformation uses Julia's node metadata system to store both:\n\nHTML structure (for UI rendering)\nPreserved AST content (for processing)\n\nHTMLBlock {html}\n├── meta[\"tab_title\"] = \"Python\"\n├── meta[\"tab_id\"] = \"tab-python\"\n└── meta[\"content\"] = BlockQuote\n    └── CodeBlock { info: \"python\", code: \"...\" }","category":"section"},{"location":"tabs/#Data-Flow","page":"Tab Transformation Guide","title":"Data Flow","text":"Original Admonition → transform_tabs() → HTMLBlock + Preserved Children\n                                         │\n                                         ├── HTML for UI rendering\n                                         └── AST nodes for processing\n                                              └── Syntax highlighting\n                                              └── Cross-references\n                                              └── Numbering","category":"section"},{"location":"tabs/#Usage","page":"Tab Transformation Guide","title":"Usage","text":"","category":"section"},{"location":"tabs/#Basic-Transformation","page":"Tab Transformation Guide","title":"Basic Transformation","text":"using MarkdownAST: MarkdownAST, Node, transform_tabs\nusing Markdown: @md_str\n\n# Create markdown with tabs\ndoc = md\"\"\"\n!!! tabs \"Python\"\n    \n    ```python\n    print(\"Hello\")\n    ```\n\n!!! tabs \"Julia\"\n    \n    ```julia\n    println(\"Hello\")\n    ```\n\"\"\"\n\n# Convert to MarkdownAST\ndoc_mdast = convert(Node, doc)\n\n# Transform tabs\ntransformed = transform_tabs(doc_mdast)","category":"section"},{"location":"tabs/#Accessing-Transformed-Content","page":"Tab Transformation Guide","title":"Accessing Transformed Content","text":"using MarkdownAST: preserve_tab_content\n\n# Find HTMLBlocks created by transformation\nfor node in transformed.children\n    if node.element isa HTMLBlock\n        content = preserve_tab_content(node)\n        if !isnothing(content)\n            # Process tab content\n            process_tab_content(content)\n        end\n    end\nend","category":"section"},{"location":"tabs/#In-Place-Transformation","page":"Tab Transformation Guide","title":"In-Place Transformation","text":"transform_tabs!(doc_mdast)  # Modifies doc_mdast directly","category":"section"},{"location":"tabs/#Integration-with-Documenter.jl","page":"Tab Transformation Guide","title":"Integration with Documenter.jl","text":"","category":"section"},{"location":"tabs/#Recommended-Implementation","page":"Tab Transformation Guide","title":"Recommended Implementation","text":"To integrate with Documenter.jl:\n\n# In your docs/make.jl\n\nusing Documenter, MarkdownAST\n\n# Your documentation pages\npages = [...]\n\n# Build documentation with custom preprocessor\nmakedocs(\n    # ... other options ...\n    pages = pages,\n    format = HTML(\n        # Custom JavaScript/CSS for tabs\n        assets = [\"assets/tabs.js\", \"assets/tabs.css\"]\n    ),\n    # Use a custom pipeline that transforms tabs\n)\n\n# Or in your documentation process:\n# 1. Load markdown document\n# 2. Convert to MarkdownAST\n# 3. Apply transform_tabs()\n# 4. Convert back for rendering with content preservation","category":"section"},{"location":"tabs/#Content-Processing-Pipeline","page":"Tab Transformation Guide","title":"Content Processing Pipeline","text":"Markdown File\n    ↓\nParse → MarkdownAST\n    ↓\ntransform_tabs() → HTMLBlocks + Preserved AST\n    ↓\n┌─ HTML Rendering  ┬─ AST Processing ─┐\n│ (UI Structure)   │ (Syntax Highlight) │\n│                  │ (Cross-refs)       │\n│                  │ (Numbering)        │\n└─────────────────┰─────────────────────┘\n                  │\n            Final Output","category":"section"},{"location":"tabs/#Content-Preservation-Details","page":"Tab Transformation Guide","title":"Content Preservation Details","text":"","category":"section"},{"location":"tabs/#What-is-Preserved","page":"Tab Transformation Guide","title":"What is Preserved","text":"Code blocks: Language info and code content retained\nEnables syntax highlighting\nAllows language-specific processing\nLists: Ordered/unordered structure maintained\nNumbering can be applied per list\nNested structures supported\nLinks: References preserved\nCross-references can be resolved\nExternal links maintained\nFormatting: Bold, italic, code preserved\nInline formatting tags retained\nText nodes preserved\nNested blocks: Quotes, admonitions, etc.\nFull nesting supported\nCan contain any valid markdown block","category":"section"},{"location":"tabs/#Example:-Code-Block-Preservation","page":"Tab Transformation Guide","title":"Example: Code Block Preservation","text":"Input Admonition:\n  category: \"tabs\"\n  title: \"Python\"\n  children: [CodeBlock(info=\"python\", code=\"print('hello')\")]\n\nAfter transformation:\nHTMLBlock { html: \"<div class='doc-tabs'>...\" }\n  meta[\"content\"] = BlockQuote\n    └── CodeBlock(info=\"python\", code=\"print('hello')\")\n        ↑ Can still apply syntax highlighting!","category":"section"},{"location":"tabs/#HTML-Generation","page":"Tab Transformation Guide","title":"HTML Generation","text":"","category":"section"},{"location":"tabs/#Generated-Structure","page":"Tab Transformation Guide","title":"Generated Structure","text":"Each tab creates this HTML structure:\n\n<div class=\"doc-tabs\" data-tab-group=\"tabs-group-{id}\">\n  <input class=\"doc-tabs-input\" type=\"radio\" name=\"tabs-group-{id}\" id=\"tab-{title}\" checked>\n  <label class=\"doc-tabs-label\" for=\"tab-{title}\">{title}</label>\n  <div class=\"doc-tabs-content\" data-tab-id=\"tab-{title}\">\n    <!-- Content will be rendered here -->\n  </div>\n</div>","category":"section"},{"location":"tabs/#Styling-with-CSS","page":"Tab Transformation Guide","title":"Styling with CSS","text":".doc-tabs {\n    border: 1px solid #ddd;\n    border-radius: 4px;\n}\n\n.doc-tabs-input {\n    display: none;\n}\n\n.doc-tabs-label {\n    display: inline-block;\n    padding: 10px 20px;\n    border-bottom: 2px solid transparent;\n    cursor: pointer;\n}\n\n.doc-tabs-input:checked + .doc-tabs-label {\n    border-bottom-color: #0066cc;\n}\n\n.doc-tabs-content {\n    display: none;\n    padding: 20px;\n}\n\n.doc-tabs-input:checked + .doc-tabs-label + .doc-tabs-content {\n    display: block;\n}","category":"section"},{"location":"tabs/#Tab-Event-Handling-with-JavaScript","page":"Tab Transformation Guide","title":"Tab Event Handling with JavaScript","text":"// For grouped tabs with synchronized switching\ndocument.querySelectorAll('.doc-tabs-input').forEach(input => {\n    input.addEventListener('change', function() {\n        const groupName = this.name;\n        const selectedId = this.id;\n        \n        // Update all tabs in the group\n        document.querySelectorAll(`input[name=\"${groupName}\"]`).forEach(tab => {\n            tab.checked = (tab.id === selectedId);\n        });\n    });\n});","category":"section"},{"location":"tabs/#Advanced-Features","page":"Tab Transformation Guide","title":"Advanced Features","text":"","category":"section"},{"location":"tabs/#Grouping-Consecutive-Tabs","page":"Tab Transformation Guide","title":"Grouping Consecutive Tabs","text":"When group_consecutive=true (default):\n\ntransform_tabs(root; group_consecutive=true)\n\nConsecutive tabs with the same category are grouped:\n\nTab 1 ─┐\nTab 2  ├─→ Single Tab Group\nTab 3 ─┘","category":"section"},{"location":"tabs/#Custom-ID-Generation","page":"Tab Transformation Guide","title":"Custom ID Generation","text":"IDs are generated from titles:\n\n\"Python\" → \"tab-python\"\n\"C++\" → \"tab-c\"\n\"Foo Bar\" → \"tab-foo-bar\"\n\nSpecial characters are removed/replaced for HTML safety.","category":"section"},{"location":"tabs/#Metadata-Access","page":"Tab Transformation Guide","title":"Metadata Access","text":"# Access tab metadata\nnode.meta[\"tab_title\"]  # Original title\nnode.meta[\"tab_id\"]     # Generated HTML ID\nnode.meta[\"content\"]    # BlockQuote with children\n\n# Check if a node is a transformed tab\nif node.element isa HTMLBlock && haskey(node.meta, \"tab_title\")\n    # This is a transformed tab\nend","category":"section"},{"location":"tabs/#Best-Practices","page":"Tab Transformation Guide","title":"Best Practices","text":"","category":"section"},{"location":"tabs/#1.-Always-Preserve-Content","page":"Tab Transformation Guide","title":"1. Always Preserve Content","text":"✅ Good: Content stored in metadata\n\n# Automatically done by transform_tabs()\nhtml_node.meta[\"content\"] = BlockQuote(children...)\n\n❌ Bad: Content lost as HTML string\n\n# Avoid this pattern\nhtml_string = \"<div>\" * string(content) * \"</div>\"","category":"section"},{"location":"tabs/#2.-Process-After-Transformation","page":"Tab Transformation Guide","title":"2. Process After Transformation","text":"# Transform first\ntransformed = transform_tabs(doc)\n\n# Then process nodes\nfor node in transformed.children\n    if node.element isa HTMLBlock\n        content = preserve_tab_content(node)\n        apply_syntax_highlighting(content)\n    end\nend","category":"section"},{"location":"tabs/#3.-Handle-Multiple-Languages","page":"Tab Transformation Guide","title":"3. Handle Multiple Languages","text":"# Each tab content is independent\nfor child in tab_content.children\n    if child.element isa CodeBlock\n        highlight_code(child.element.info, child.element.code)\n    end\nend","category":"section"},{"location":"tabs/#Troubleshooting","page":"Tab Transformation Guide","title":"Troubleshooting","text":"","category":"section"},{"location":"tabs/#Issue:-Content-not-preserved","page":"Tab Transformation Guide","title":"Issue: Content not preserved","text":"Solution: Check node metadata\n\nif node.element isa HTMLBlock\n    content = preserve_tab_content(node)\n    @assert !isnothing(content)\nend","category":"section"},{"location":"tabs/#Issue:-HTML-is-escaped-twice","page":"Tab Transformation Guide","title":"Issue: HTML is escaped twice","text":"Solution: escaping is done once at generation\n\n# Don't re-escape when rendering\nrender_html(node.element.html)  # Already safe","category":"section"},{"location":"tabs/#Issue:-Tabs-not-grouped","page":"Tab Transformation Guide","title":"Issue: Tabs not grouped","text":"Solution: Use group_consecutive=true parameter\n\ntransform_tabs(root; group_consecutive=true)","category":"section"},{"location":"tabs/#API-Reference","page":"Tab Transformation Guide","title":"API Reference","text":"","category":"section"},{"location":"tabs/#Main-Functions","page":"Tab Transformation Guide","title":"Main Functions","text":"transform_tabs(root::Node; group_consecutive::Bool=true) -> Node\ntransform_tabs!(root::Node; group_consecutive::Bool=true) -> Node\npreserve_tab_content(node::Node) -> Union{Node, Nothing}","category":"section"},{"location":"tabs/#Internal-Functions","page":"Tab Transformation Guide","title":"Internal Functions","text":"_generate_tab_id(title::String) -> String\n_generate_tab_html(title::String, tab_id::String, group_id::String) -> String\nescape_html(str::String) -> String","category":"section"},{"location":"tabs/#Examples","page":"Tab Transformation Guide","title":"Examples","text":"See examples/tabs_transformation.jl for complete working examples.","category":"section"},{"location":"tabs/#See-Also","page":"Tab Transformation Guide","title":"See Also","text":"AST Macro Documentation\nNode Documentation\nMarkdownAST Elements","category":"section"},{"location":"node/#Tree-node-interface","page":"Tree node interface","title":"Tree node interface","text":"The Markdown abstract syntax tree (AST) is a tree of Markdown elements. In order to avoid type instabilities when performing basic operations on a tree, such as traversin it, it is implemented by linking together instances of the Node type. Each Node instance functions as a container for some AbstractElement.\n\nThe Node type has various properties that can be used to access information about the structure of the tree, but it is generally not possible to set them directly. Changing the structure of a tree (e.g. to adding child nodes), should be done with the help of the various functions and methods to MarkdownAST provides for mutating the tree.","category":"section"},{"location":"node/#Accessing-child-nodes","page":"Tree node interface","title":"Accessing child nodes","text":"Internally, to store the children, a node simply stores the reference to the first and the last child node, and each child stores the references to the next and previous child. The .children property is implemented simply as a lazy iterator of type NodeChildren that traverses the linked list. As such, some operations, such as determining the number of children a node has with length, can have unexpected O(n) complexity.","category":"section"},{"location":"node/#Mutating-the-tree","page":"Tree node interface","title":"Mutating the tree","text":"The following functions and methods can be used to mutate the Markdown AST trees represented using Node objects. When using these methods, the consistency of the tree is preserved (i.e. the references between the affected nodes are correctly updated). Changing the structure of the tree in any other way should generally be avoided, since the code that operates on trees generally assumes a consistent tree, and will likely error or behave in unexpected ways on inconsistent trees.\n\nwarning: Mutating the tree while traversing\nMutating the structure of the tree while traversing it with some iterator (e.g. .children or one of the AbstractTrees iterators) can lead to unexpected behavior and should generally be avoided. Updating the .element of a node while traversing, on the other hand, is fine. In general, replace! can be used to mutate a tree in arbitrary ways.\n\nnote: Mutating the .children property\nThe choice to apparently mutate the .children property when adding child nodes is purely syntactic, and in reality the operation affects the parent Node object. Internally the .children iterator is simply a thin wrapper around the parent node.","category":"section"},{"location":"node/#Copying-trees","page":"Tree node interface","title":"Copying trees","text":"The copy_tree function can be used to easily copy a tree.\n\nThis can be particularly useful in circumstances where a tree is passed to other code that while processing the tree also mutates it. As Node is a mutable type, this means that the original tree also mutates. Passing the result from copy_tree can be used to avoid that issue.","category":"section"},{"location":"node/#Index","page":"Tree node interface","title":"Index","text":"Pages = [\"node.md\"]","category":"section"},{"location":"node/#MarkdownAST.Node","page":"Tree node interface","title":"MarkdownAST.Node","text":"mutable struct Node{M}\n\nImplements a linked list type representation of a Markdown abstract syntax tree, where each node contains pointers to the children and parent nodes, to make it possible to easily traverse the whole tree in any direction. Each node also contains an \"element\", which is an instance of some AbstractElement subtype, and can be accessed via the .element property. The element object contains the semantic information about the node (e.g. wheter it is a list or a paragraph).\n\nOptionally, each node can also store additional meta information, which will be an object of type M (see also the .meta property). By default, the node does not contain any extra meta information and M = Nothing.\n\nConstructors\n\nNode(element :: AbstractElement)\n\nConstructs a simple standalone node (not part of any tree) without any additional metadata (M = Nothing) containing the Markdown AST element c.\n\nNode{M}(element :: AbstractElement, meta :: M)\n\nConstructs a simple standalone node (not part of any tree) with the meta information meta, containing the Markdown AST element c.\n\nExtended help\n\nThere are various properties that can be used to access the details of a node. Many of them can not be set directly though, as that could lead to an inconsistent tree. Similarly, the underlying fields of the struct should not be accessed directly.\n\n.meta :: M: can be used to access or set the extra meta information of the node.\n.element :: T where {T <: AbstractElement}: can be used to access or set the element corresponding to the node\n.next :: Union{Node{M},Nothing}: access the next child node after this one, with the value set to nothing if there is no next child\n.previous :: Union{Node{M},Nothing}: access the previous child node before this one, with the value set to nothing if there is no such node\n.parent :: Union{Node{M},Nothing}: access the parent node of this node, with the value set to nothing if the node does not have a parent\n.children: an iterable object of type NodeChildren that can be used to access and modify the child nodes of this node\n\nThe .children field is implemented with a wrapper type that implemements the iteration protocol. However, the exact type information etc. is an implementation detail, and one should only rely on the following documented APIs:\n\nThe following methods are implemented for .children: length, eltype, first, last, isempty, empty!\nAppending or prepending new children to a parent node can be done with the push!, pushfirst!, append!, and prepend! methods\n\nOther ways to work with child nodes that do not directly reference .children are:\n\nTo add new children between others, the insert_after!, insert_before! functions can be used to insert new children relative to a reference child node.\nTo remove a child from a node, the unlink! function can be used on the corresponding child node.\n\nIn addition, there are other functions and methods that can be used to work with nodes and trees:\n\nQuerying information about the node: haschildren\nRemoving a node from a tree: unlink!\nTwo trees can be compared with the == operator\nMutating a tree: replace! and replace\n\n\n\n\n\n","category":"type"},{"location":"node/#Base.:==-Union{Tuple{T}, Tuple{MarkdownAST.Node{T}, MarkdownAST.Node{T}}} where T","page":"Tree node interface","title":"Base.:==","text":"==(x::Node, y::Node) -> Bool\n\nDetermines if two trees are equal by recursively walking through the whole tree (if need be) and comparing each node. Parent nodes are ignored when comparing for equality (so that it would be possible to compare subtrees). If the metadata type does not match, the two trees are not considered equal.\n\n\n\n\n\n","category":"method"},{"location":"node/#MarkdownAST.haschildren","page":"Tree node interface","title":"MarkdownAST.haschildren","text":"haschildren(node::Node) -> Bool\n\nReturns true if node has any children nodes and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"node/#MarkdownAST.NodeChildren","page":"Tree node interface","title":"MarkdownAST.NodeChildren","text":"struct NodeChildren\n\nThe type of the the .children property of a Node which acts as an iterator over the children of a node. This type is mostly considered to be an implementation detail, and only has the following publicly defined APIs:\n\nThe name of the type NodeChildren, so that it could be dispatched on.\nThe .parent :: Node field that allows the user to access the parent node of the children.\n\n\n\n\n\n","category":"type"},{"location":"node/#Base.eltype-Union{Tuple{Type{MarkdownAST.NodeChildren{T}}}, Tuple{T}} where T","page":"Tree node interface","title":"Base.eltype","text":"eltype(node.children::NodeChildren) = Node{M}\n\nReturns the exact Node type of the tree, corresponding to the type of the elements of the .children iterator.\n\n\n\n\n\n","category":"method"},{"location":"node/#Base.length-Tuple{MarkdownAST.NodeChildren}","page":"Tree node interface","title":"Base.length","text":"length(node.children::NodeChildren) -> Int\n\nReturns the number of children of node :: Node.\n\nAs the children are stored as a linked list, this method has O(n) complexity. As such, to check there are any children at all, it is generally preferable to use isempty.\n\n\n\n\n\n","category":"method"},{"location":"node/#Base.isempty-Tuple{MarkdownAST.NodeChildren}","page":"Tree node interface","title":"Base.isempty","text":"isemtpy(node.children::NodeChildren) -> Bool\n\nCan be called on the .children field of a node :: Node to determine whether or not the node has any child nodes.\n\n\n\n\n\n","category":"method"},{"location":"node/#Base.first-Union{Tuple{MarkdownAST.NodeChildren{T}}, Tuple{T}} where T","page":"Tree node interface","title":"Base.first","text":"first(node.children::NodeChildren) -> Node\n\nReturns the first child of the node :: Node, or throws an error if the node has no children.\n\n\n\n\n\n","category":"method"},{"location":"node/#Base.last-Union{Tuple{MarkdownAST.NodeChildren{T}}, Tuple{T}} where T","page":"Tree node interface","title":"Base.last","text":"last(node.children::NodeChildren) -> Node\n\nReturns the last child of the node :: Node, or throws an error if the node has no children.\n\n\n\n\n\n","category":"method"},{"location":"node/#Base.replace-Union{Tuple{T}, Tuple{Function, T}} where T<:MarkdownAST.Node","page":"Tree node interface","title":"Base.replace","text":"replace(f::Function, root::Node) -> Node\n\nCreates a copy of the tree where all child nodes of root are recursively (post-order depth-first) replaced by the result of f(child).\n\nThe function f(child::Node) must return either a new Node to replace child or a Vector of nodes that will be inserted as siblings, replacing child.\n\nNote that replace does not allow the construction of invalid trees, and element replacements that require invalid parent-child relationships (e.g., a block element as a child to an element expecting inlines) will throw an error.\n\nExample\n\nThe following snippet removes links from the given AST. That is, it replaces Link nodes with their link text (which may contain nested inline markdown elements):\n\nnew_mdast = replace(mdast) do node\n    if node.element isa MarkdownAST.Link\n        return [MarkdownAST.copy_tree(child) for child in node.children]\n    else\n        return node\n    end\nend\n\n\n\n\n\n","category":"method"},{"location":"node/#Base.replace!-Tuple{Function, MarkdownAST.Node}","page":"Tree node interface","title":"Base.replace!","text":"replace!(f::Function, root::Node) -> Node\n\nActs like replace(f, root), but modifies root in-place.\n\n\n\n\n\n","category":"method"},{"location":"node/#MarkdownAST.unlink!","page":"Tree node interface","title":"MarkdownAST.unlink!","text":"unlink!(node::Node) -> Node\n\nIsolates and removes the node from the tree by removing all of its links to its neighboring nodes. Returns the updated node, which is now a single, isolate root node.\n\n\n\n\n\n","category":"function"},{"location":"node/#MarkdownAST.insert_before!","page":"Tree node interface","title":"MarkdownAST.insert_before!","text":"insert_before!(node::Node, sibling::Node) -> Node\n\nInserts a new child node sibling as the child right before node. node must not be a root node. If sibling is part of another tree, then it is unlinked from that tree first (see unlink!). Returns the original reference node.\n\n\n\n\n\n","category":"function"},{"location":"node/#MarkdownAST.insert_after!","page":"Tree node interface","title":"MarkdownAST.insert_after!","text":"insert_after!(node::Node, sibling::Node) -> Node\n\nInserts a new child node sibling as the next child after node. node must not be a root node. If sibling is part of another tree, then it is unlinked from that tree first (see unlink!). Returns the original reference node.\n\n\n\n\n\n","category":"function"},{"location":"node/#Base.push!-Union{Tuple{T}, Tuple{MarkdownAST.NodeChildren{T}, T}} where T<:MarkdownAST.Node","page":"Tree node interface","title":"Base.push!","text":"Base.push!(node.children::NodeChildren, child::Node) -> NodeChildren\n\nAdds child as the last child node of node :: Node. If child is part of another tree, then it is unlinked from that tree first (see unlink!). Returns the iterator over children.\n\n\n\n\n\n","category":"method"},{"location":"node/#Base.pushfirst!-Union{Tuple{T}, Tuple{MarkdownAST.NodeChildren{T}, T}} where T<:MarkdownAST.Node","page":"Tree node interface","title":"Base.pushfirst!","text":"Base.pushfirst!(node.children::NodeChildren, child::Node) -> NodeChildren\n\nAdds child as the first child node of node :: Node. If child is part of another tree, then it is unlinked from that tree first (see unlink!). Returns the iterator over children.\n\n\n\n\n\n","category":"method"},{"location":"node/#Base.append!-Union{Tuple{T}, Tuple{MarkdownAST.NodeChildren{T}, Any}} where T","page":"Tree node interface","title":"Base.append!","text":"append!(node.children::NodeChildren, children) -> NodeChildren\n\nAdds all the elements of the iterable children to the end of the list of children of node. If any of children are part of another tree, then they are unlinked from that tree first (see unlink!). Returns the iterator over children.\n\nwarning: Error during an append\nThe operation is not atomic, and an error during an append! (e.g. due to an element of the wrong type in children) can result in a partial append of the new children, similar to how append! behaves with arrays (see JuliaLang/julia#15868).\n\n\n\n\n\n","category":"method"},{"location":"node/#Base.prepend!-Union{Tuple{T}, Tuple{MarkdownAST.NodeChildren{T}, Any}} where T","page":"Tree node interface","title":"Base.prepend!","text":"prepend!(node.children::NodeChildren, children) -> NodeChildren\n\nAdds all the elements of the iterable children to the beginning of the list of children of node. If any of children are part of another tree, then they are unlinked from that tree first (see unlink!). Returns the iterator over children.\n\nwarning: Error during a prepend\nThe operation is not atomic, and an error during a prepend! (e.g. due to an element of the wrong type in children) can result in a partial prepend of the new children, similar to how append! behaves with arrays (see JuliaLang/julia#15868).\n\n\n\n\n\n","category":"method"},{"location":"node/#Base.empty!-Tuple{MarkdownAST.NodeChildren}","page":"Tree node interface","title":"Base.empty!","text":"empty!(node.children::NodeChildren) -> NodeChildren\n\nRemoves all the children of a node.\n\n\n\n\n\n","category":"method"},{"location":"node/#MarkdownAST.copy_tree","page":"Tree node interface","title":"MarkdownAST.copy_tree","text":"copy_tree(root::Node)\ncopy_tree(f, root::Node)\n\nCreates a copy of the tree, starting from node as the root node, and  optionally calling f on each of the nodes to determine the corresponding .element in the copied tree.\n\nIf node is not the root of its tree, its parent nodes are ignored, and the root node of the copied node corresponds to node.\n\nThe function f should have the signature (::Node, ::AbstractElement) -> AbstractElement, and it gets passed the current node being copied and its element. It must return an instance of some AbstractElement, which will then be assigned to the .element field of the copied node. By default, copy_tree performs a deepcopy of both the element (.element) and the node metadata (.meta).\n\nExtended help\n\nFor example, to perform a copy instead of deepcopy on the elements, copy_tree can be called as follows\n\ncopy_tree((_, e) -> copy(e), node::Node)\n\nNote that copy_tree does not allow the construction of invalid trees, and element replacements that require invalid parent-child relationships (e.g. a block element as a child to an element expecting inlines) will throw an error.\n\n\n\n\n\n","category":"function"},{"location":"#MarkdownAST","page":"Introduction","title":"MarkdownAST","text":"The structure of a Markdown file can be represented as an abstract syntax tree. The MarkdownAST package defines a Julia interface for representing such trees to facilitate the interoperability between different packages that deal with Markdown documents in different ways.\n\nWhile the primary goal is to represent Markdown documents, the tree structure, implemented by the Node type and the AbstractElement subtypes, is intentionally generic and can also be used to represent more general documents.","category":"section"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"This tutorial shows how to use MarkdownAST's tab transformation step by step, based on the example in examples/tabs_transformation.jl.","category":"section"},{"location":"tutorial/#1.-Create-a-markdown-document-with-tab-admonitions","page":"Tutorial","title":"1. Create a markdown document with tab admonitions","text":"Tab admonitions use the !!! tabs category. Each ## heading inside becomes a tab label.\n\nusing MarkdownAST: MarkdownAST, Node, transform_tabs_admonitions\nusing Markdown: @md_str\n\ndoc = md\"\"\"\n# Tab Examples\n\n## Python vs Julia\n\n!!! tabs \"Language Comparison\"\n\n    ## Python\n\n    Python's simple syntax:\n\n    ```python\n    def hello():\n        print(\"Hello from Python\")\n    ```\n\n    ## Julia\n\n    Julia's performance-oriented syntax:\n\n    ```julia\n    function hello()\n        println(\"Hello from Julia\")\n    end\n    ```\n\n## Installation Instructions\n\n!!! tabs \"Install\"\n\n    ## Windows\n\n    Download from the official website:\n\n    ```bash\n    choco install mypackage\n    ```\n\n    ## Linux\n\n    Use your package manager:\n\n    ```bash\n    sudo apt-get install mypackage\n    ```\n\n    ## macOS\n\n    Using Homebrew:\n\n    ```bash\n    brew install mypackage\n    ```\n\"\"\"","category":"section"},{"location":"tutorial/#2.-Convert-to-a-MarkdownAST-tree","page":"Tutorial","title":"2. Convert to a MarkdownAST tree","text":"transform_tabs_admonitions is automatically called during convert, turning each !!! tabs admonition into a series of HTMLBlock nodes while preserving the child AST nodes (code blocks, paragraphs, etc.) for downstream processing such as syntax highlighting.\n\ndoc_mdast = convert(Node, doc)\nprintln(doc_mdast)","category":"section"},{"location":"tutorial/#3.-Inspect-the-transformed-tree","page":"Tutorial","title":"3. Inspect the transformed tree","text":"We can walk the tree and identify the HTMLBlock nodes produced by the transformation as well as the preserved CodeBlock nodes inside them.\n\nfunction analyze_tabs(node::Node, depth=0)\n    indent = \"  \" ^ depth\n\n    if node.element isa MarkdownAST.HTMLBlock\n        html = node.element.html\n        if occursin(\"doc-tabs\\\"\", html)\n            println(\"$(indent)Found tab container\")\n        elseif occursin(\"doc-tabs__labels\", html)\n            println(\"$(indent)Found labels container\")\n        elseif occursin(\"doc-tabs__label\", html)\n            m = match(r\">([^<]+)</button>\", html)\n            m !== nothing && println(\"$(indent)✓ Tab label: \\\"$(m[1])\\\"\")\n        elseif occursin(\"doc-tabs__panel\", html)\n            m = match(r\"data-tab=\\\"(\\d+)\\\"\", html)\n            m !== nothing && println(\"$(indent)✓ Panel (tab #$(m[1]))\")\n        elseif occursin(\"</div>\", html)\n            println(\"$(indent)✓ Closing div tag\")\n        end\n    end\n\n    if node.element isa MarkdownAST.CodeBlock\n        println(\"$(indent)✓ Preserved CodeBlock: language='$(node.element.info)'\")\n    elseif node.element isa MarkdownAST.Heading\n        println(\"$(indent)✓ Preserved Heading: level=$(node.element.level)\")\n    elseif node.element isa MarkdownAST.Paragraph && !isempty(node.children)\n        println(\"$(indent)✓ Preserved Paragraph with content\")\n    end\n\n    for child in node.children\n        analyze_tabs(child, depth + 1)\n    end\nend\n\nanalyze_tabs(doc_mdast)","category":"section"},{"location":"tutorial/#Summary","page":"Tutorial","title":"Summary","text":"After the transformation:\n\n!!! tabs admonitions are converted to HTMLBlock nodes (for UI rendering).\nTab labels (the ## headings) become <button> elements.\nCode blocks and other content remain as AST nodes for syntax highlighting and further processing.","category":"section"}]
}
